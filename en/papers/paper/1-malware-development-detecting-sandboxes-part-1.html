

<!DOCTYPE html>
<html lang="en">
    <style>
    .ascii {
        color: black;
        padding: 30px;
        text-align: center;
        background-image: url('../../asciiart.png');
        background-repeat: no-repeat;
        background-position: center;
        background-color: black;
    }

    .nav {
        overflow: hidden;
        background-color: rgb(5, 5, 5);
    }
    
    .nav a {
        float: left;
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
        font-family: monospace;
    }
    
    .nav a:hover {
        background-color: rgb(160, 13, 197);
        color: white;
    }

    .card {
    color: #000;
    background-color: #aaa;
    padding: 20px;
    margin-top: 20px;
    }
    </style>
    <title>Paper: #1 Malware Development: Detecting Sandboxes - Part 1 - Amolo Hunters</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=1024">
    <meta name="viewport" content="width=1024">
    <link rel="icon" type="image/x-icon" href="../../favicon.ico">
    <body style="background-color:black;">
        <div class="nav">
            <a href="../../index.html">Home</a>
            <a href="../../papers/">Papers</a>
            <a href="../../wallpapers/">Wallpapers</a>
            <a href="../../members/">Members</a>
        </div>
        <div class="ascii">
            <h1 style="color:black;" align="right">.</h1>
            <h1 style="color:black;" align="right">.</h1>
        </div>
        <h1 style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">#1 Malware Development: Detecting Sandboxes - Part 1</h1>
        <p style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">Author: @mrempy</p>
        <div>
                <pre style="color:white;">
      ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣶⠖⠀⠀⠲⣶⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⡿⠋⠀⠀⠀⠀⠀⠀⠙⢿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⠀⠀⢀⣾⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣷⡀⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⠀⠀⣾⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣷⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⠀⠀⣿⣿⣿⣇⣤⠶⠛⣛⣉⣙⡛⠛⢶⣄⣸⣿⣿⣿⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⢀⣀⣿⣿⣿⡟⢁⣴⣿⣿⣿⣿⣿⣿⣦⡈⢿⣿⣿⣿⣀⡀⠀⠀⠀⠀
      ⠀⠀⢠⣴⣿⣿⣿⣿⡟⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡌⢿⣿⣿⣿⣿⣦⡄⠀⠀
      ⠀⣴⣿⣿⡿⠿⢛⣻⡇⢸⡟⠻⣿⣿⣿⣿⣿⡿⠟⢻⡇⣸⣛⡛⠿⣿⣿⣿⣦⠀
      ⢸⣿⡿⠋⠀⠀⢸⣿⣿⡜⢧⣄⣀⣉⡿⣿⣉⣀⣠⣼⢁⣿⣿⡇⠀⠀⠙⢿⣿⡆
      ⣿⣿⠁⠀⠀⠀⠈⣿⣿⡇⣿⡿⠛⣿⣵⣮⣿⡟⢻⡿⢨⣿⣿⠀⠀⠀⠀⠈⣿⣿
      ⢿⡟⠀⠀⠀⠀⠀⠘⣿⣷⣤⣄⡀⣿⣿⣿⣿⢁⣤⣶⣿⣿⠃⠀⠀⠀⠀⠀⣿⡟
      ⠘⠇⠀⠀⠀⠀⠀⠀⠈⠻⣿⣿⡇⢿⣿⣿⣿⢸⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠻⠃
      ⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⢩⣦⣘⡘⠋⣛⣸⡍⠁⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀
      ⠀⠀⠘⢿⣷⣤⣤⣄⣤⣤⣶⣿⣿⣿⡿⢿⣿⣿⣿⣷⣤⣤⣠⣤⣴⣾⡿⠁⠀⠀
      ⠀⠀⠀⠀⠉⠛⠿⠿⠿⡿⠿⠿⠛⠉⠀⠀⠉⠛⠿⠿⣿⠿⠿⠿⠛⠉⠀⠀⠀⠀



        ╔═══════════════[Summary]═════════════╗
        ║                                     ║
        ║     1. Introduction                 ║
        ║     2. Writing Codes                ║
        ║       2.1 Anti-Debugging            ║
        ║       2.2 Anti-Dumping              ║
        ║       2.3 Suspicious Process        ║
        ║     3. Complete Code                ║
        ║                                     ║
        ╚═════════════════════════════════════╝


        <a style="font-size: 20px;">Introduction</a>

        One of the fundamental things in good malware is the ability not to execute itself if it is in a controlled, known environment.
        like sandboxes. Many malware developers implement anti-sandbox techniques in their codes to prevent malware from
        researcher is unable to debug and analyze the malware.

        In this paper, I will present <b>3</b> techniques to implement in your codes against sandboxes. Let's go!


        <a style="font-size: 20px;">Writing Codes</a>

        Let's write 3 functions, these are:
            * DebuggerPresent() - Detects whether there is a debugger present in the executable process.
            * ErasePEHeader() - Technique to prevent dumping of the executable in memory (Anti-Dumping).
            * SandboxSuspectProcess() - Will detect if there are any suspicious processes in sandboxes.


        <a style="font-size: 15px;">Anti-Debugging</a>

        For this function, we will use two Windows APIs, known as <b>IsDebuggerPresent</b> and <b>CheckRemoteDebuggerPresent</b>.
        Using these APIs is very simple, just implement them like this:

        ╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
        ║ // 1. Debugger Present                                                                                                   ║
        ║ BOOL DebuggerPresent() {                                                                                                 ║
        ║     if (IsDebuggerPresent()) {                                              // Check if there is a debugger present      ║
        ║         return 1;                                                                                                        ║
        ║     }                                                                                                                    ║
        ║                                                                                                                          ║
        ║     BOOL remoteDbgPresent;                                                                                               ║ 
        ║     CheckRemoteDebuggerPresent(GetCurrentProcess(), &remoteDbgPresent);     // Verify that it is being debugged remotely ║ 
        ║     if (remoteDbgPresent) {                                                                                              ║
        ║         return 1;                                                                                                        ║
        ║     }                                                                                                                    ║
        ║                                                                                                                          ║
        ║     return 0;                                                                                                            ║
        ║ }                                                                                                                        ║
        ╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

        IsDebuggerPresent: This API is part of the Windows standard library (windows.h). Using it is very simple, you just need
        add it together with an "if" in a boolean function to return true or false (0 or 1), as in the code above. If there is a
        debugger attached to the process, it will return false, otherwise it will return true.

        CheckRemoteDebuggerPresent: This is another API that is part of the same library as the previous API. It serves to detect
        whether a remote process is being debugged. If there is a debugger, it will return false, otherwise it will return true.
        The boolean "remoteDbgPresent" will be responsible for this state.

        We can call our function like this:

        ╔══════════════════════════════════════╗
        ║ if (DebuggerPresent() != 0) {        ║
        ║     puts("[-] Debugger is present"); ║
        ║ }                                    ║
        ╚══════════════════════════════════════╝

        <b>NOTE</b>: If you call your function inside an "int", don't forget to add "return 1;", or if it's a "void", add
        "exit(0);".


        <a style="font-size: 15px;">Anti-Dumping</a>

        Anti-Dumping is a technique that does not allow a user to dump the memory of the running process by clearing the Portable header
        Executable (PE Header). Using this technique, you may end up making the process of reverse engineering your malware more difficult, as
        when the malware researcher goes through its function and tries to dump the memory of the executable process, the result will be invalid,
        and it will not be able to run the EXE dumped from the process.

        Let's create our function for this job:

        ╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
        ║ // 2. Anti-Dumping                                                                                                                   ║
        ║ BOOL ErasePEHeader() {                                                                                                               ║
        ║     DWORD oldProtect = 0;                                                                                                            ║
        ║                                                                                                                                      ║
        ║     char* processBaseAddress = (char*)GetModuleHandle(NULL);                  // Get the base address of our running EXE             ║
        ║                                                                                                                                      ║ 
        ║     VirtualProtect(processBaseAddress, 4096, PAGE_READWRITE, &oldProtect);   // Releases access to read and write to the pe32 header ║
        ║                                                                                                                                      ║ 
        ║     RtlZeroMemory(processBaseAddress, 4096);                                 // Clean PE header                                      ║
        ║                                                                                                                                      ║ 
        ║     return 0;                                                                                                                        ║
        ║ }                                                                                                                                    ║
        ╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

        DWORD oldProtect: we will add a variable of type DWORD to store the old protect of the process.

        char* processBaseAddress: this line of code will return the process handle, that is, the memory base of our executable, where
        will be stored in the processBaseAddress variable.

        VirtualProtect: this API will be responsible for allowing reading and writing from the base address of the process up to 4096 bytes.

        RtlZeroMemory: this API will be used to fill the 4096 bytes of the PE header with zeros.

        You can call this function just by writing "ErasePEHeader();".


        <a style="font-size: 15px;">Suspicious Processes</a>

        In this part, we will work with process detection based on their names, for example, the wireshark process, ollydbg, and others.
        To do this, we need to create a list of process names, I will make this list and the complete code available:

        ╔═════════════════════════════════════╗
        ║ const wchar_t* sandboxProcess[] = { ║
        ║     L"filemon.exe",                 ║
        ║     L"PETools.exe",                 ║
        ║     L"tcpview.exe",                 ║
        ║     L"idaq.exe",                    ║
        ║     L"regmon.exe",                  ║
        ║     L"dumpcap.exe",                 ║
        ║     L"LordPE.exe",                  ║
        ║     L"idaq64.exe",                  ║
        ║     L"httpdebugger.exe",            ║
        ║     L"tcpview.exe",                 ║
        ║     L"proc_analyzer.exe",           ║
        ║     L"idaq.exe",                    ║
        ║     L"procmon.exe",                 ║
        ║     L"ResourceHacker.exe",          ║
        ║     L"joeboxcontrol.exe",           ║
        ║     L"joeboxserver.exe",            ║
        ║     L"ollydbg.exe",                 ║
        ║     L"HookExplorer.exe",            ║
        ║     L"SysInspector.exe",            ║
        ║     L"autorunsc.exe",               ║
        ║     L"autoruns.exe",                ║
        ║     L"Windbg.exe",                  ║
        ║     L"Fiddler.exe",                 ║
        ║     L"joeboxserver.exe",            ║
        ║     L"ImmunityDebugger.exe",        ║
        ║     L"filemon.exe",                 ║
        ║     L"sniff_hit.exe",               ║
        ║     L"Wireshark.exe",               ║
        ║     L"x64dbg.exe"                   ║
        ║ };                                  ║
        ╚═════════════════════════════════════╝

        Now we need to create a function to get the process id of these processes:

        ╔════════════════════════════════════════════════════════════════════╗
        ║ DWORD GetPID(LPCWSTR exeName) {                                    ║
        ║     DWORD processId = 0;                                           ║
        ║     HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); ║
        ║                                                                    ║
        ║     if (snap != INVALID_HANDLE_VALUE)                              ║
        ║     {                                                              ║
        ║         PROCESSENTRY32 pe32;                                       ║
        ║         pe32.dwSize = sizeof(pe32);                                ║
        ║                                                                    ║
        ║         if (Process32First(snap, &pe32))                           ║
        ║         {                                                          ║
        ║             if (!pe32.th32ProcessID)                               ║
        ║                Process32Next(snap, &pe32);                         ║
        ║            do                                                      ║
        ║             {                                                      ║
        ║                 if (!lstrcmpiW((LPCWSTR)pe32.szExeFile, exeName))  ║
        ║                 {                                                  ║
        ║                     processId = pe32.th32ProcessID;                ║
        ║                     break;                                         ║
        ║                 }                                                  ║
        ║             } while (Process32Next(snap, &pe32));                  ║
        ║         }                                                          ║
        ║     }                                                              ║
        ║     CloseHandle(snap);                                             ║
        ║                                                                    ║
        ║     return processId;                                              ║
        ║ }                                                                  ║
        ╚════════════════════════════════════════════════════════════════════╝

        This function will return the process ID after finding it, if not found, it will return 0.

        Now let's create the function that will go through the list of processes and see if it exists or not:

        ╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
        ║ // 3. Sandbox Process                                                                                                                                    ║
        ║ BOOL SandboxSuspectProcess() {                                                                                                                           ║
        ║     for (int i = 0; i < sizeof(sandboxProcess) / sizeof(sandboxProcess[0]); i++) {          // Cycle through the entire list of common sandbox processes ║
        ║         DWORD pid = GetPID(sandboxProcess[i]);                                              // Get the PID of the process by name                        ║
        ║                                                                                                                                                          ║
        ║         if (pid != 0) {                                                                     // Checks if the returned PID is different from 0            ║
        ║             return 1;                                                                       // If it is different from 0, it means there is a            ║
        ║         }                                                                                   // suspicious process                                        ║
        ║     }                                                                                                                                                    ║
        ║                                                                                                                                                          ║
        ║     return 0;                                                                                                                                            ║
        ║ }                                                                                                                                                        ║
        ╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

        In short, this function will go through the list of suspicious processes and will get the PID through the "GetPID" function and will store the result
        in the "pid" variable. If the result of the "pid" variable is not equal to 0, it means that one of the processes in the list is running, so the function will
        return false. If all PIDs results are 0, it will return 0.

        Implement your function like this:

        ╔══════════════════════════════════════════════════════════════╗
        ║ if (SandboxSuspectProcess() != 0) {                          ║
        ║     puts("[-] There are sandbox processes on this machine"); ║
        ║ }                                                            ║
        ║ else {                                                       ║
        ║     puts("[+] There are no suspicious processes");           ║
        ║ }                                                            ║
        ╚══════════════════════════════════════════════════════════════╝

        Perfect! Everything is ready to be compiled and tested.
        
        <a style="font-size: 20px;">Full Code</a>

        The complete code can be found at:

        https://github.com/AmoloHT/PapersArchives/tree/main/1-malware-development-detecting-sandboxes-part-1

        The code is finished, now it's time to compile and run :)

                             _--_
                            /   -)
                        ___/___|___
           ____-----=~~///|     ||||~~~==-----_____
         //~////////////~/|     |//|||||\\\\\\\\\\\\\
       ////////////////////|   |///////|\\\\\\\\\\\\\\\
      /////~~~~~~~~~~~~~~~\ |.||/~~~~~~~~~~~~~~~~~`\\\\\
     //~                  /\\|\\                      ~\\
                         ///W^\W\
                        ////|||\\\
                        ~~~~~~~~~~     

                      Amolo Hunters!

                </pre>                    
        </div>
    </body>
</html>
